Placement
    An immutable set of coords representing a single omino that's actually at a location on a board.
    The call omino.place(size,at) tries to make a placement of that omino at that location on that sized board.
    The call omino.place(size) collects the successes and produces a list of possible placement for an omino.

cellToPlacement
    A Map<Coords,MutableList<Placement>>
    For each coords on the grid, this is the list of placements that cover it.
    Given a placement, we can always populate this map.

The cellToPlacement is one data struct, but is effectively the many-to-many relationship from the algo.
We can go from cell to all its placements, and we can go from a placement to all its cells. We can also determine
which cells have the fewest placements available.

Move
    This is an actual move in the "game tree" of the algorithm. It specifies a particular placement and the
    needed information to undo that placement (and possibly any follow-on moves).
    placement - the actual placement
    collisions - the placements this one makes illegal, that were hence removed from the map by this move.
    examined - the placements from child moves that have already been tried but failed

move()
    move.placement = pick a placement from cellToPlacement
    for each cell in move.placement
        remove move.placement from it
        for each remaining placement that uses that cell
            for cell in remaining
                remove placement from map[cell]

Link
    List of coords.

Placement
    Conceptually, for a placement of order O there are O links. Each of these has the same constituents, but with
    a different zero'th member. ABC BAC CAB, for instance.

    links -- the O links for the placement
    collision links -- links that were removed because they conflict with links
    examined links -- links that following moves tried to use but failed

backtrack
    moves are kept in a stack that represent the part of the move tree we're exploring
    move = pop()
    previous = lastOrNull()
    put move's placement in previous's examined links list
        note: if you're popping the 0th move, its placements are truly dead. Put them on the solver's reset list.
    put move's collisions back in the map
    put move's examineds back in the map

reset
    backtrack until there are no placements
    restore the reset list

move
    pick a link
    links = link + its O-1 re-orderings
    remove links from table
    collisions = any table link that contains one of the placement's coordinates
    examined = []

backtrackIfNeeded
    Any time we don't have any links in the table, we've hit a dead end.
    We want to backtrack until the table has links again, which may be multiple times.
    If we still are out of links after we've emptied the stack, we have an unsolvable problem.

solve()
    generate all ominos
    generate all links
    while(placements<P)
        if backtrackIfNeeded still doesn't get links in the table
            exit with failure
        move


Given order O ominos in a W by H plane, the number of placements P = (W*H)/O, which must be an integer.
Example: pentominos in a 5x5 is P = 5. trominos in a 6x6 is P = 12.

While the solution doesn't have enough placements
    backtrackIfNeeded()
        while links is empty, and solution has placements backtrack
            pop the most recent placement
            put the collisions links back in the list
            put the dead links in the solution's reset list
        If there are no placements and no links we're dead!
    Pick a link

    Remove each link with the same constituents and put it in dead links.
        These are dead links, and will not come back. Either this tiling works, and doesn't come back,
        or we'll hit a dead end, and it means this placement isn't valid given the prior placements.

    Remove each link with *any* of the constituents and put it in backtrack links.
        There are backtrackable links, and may come back. If we backtrack, these are still valid links,
        because they're different from the one we chose.

If we exit the loop because we have enough placements, we have a solution.
If we run out of links, we have to backtrack.




