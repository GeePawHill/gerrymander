Placement
    An immutable set of coords representing a single omino that's actually at a location on a board.
    (Ominos are themselves always normalized to least-x and least-y)
    The call omino.place(size,at) tries to make a placement of that omino at that location on that sized board.
    The call omino.place(size) collects the successes and produces a list of possible placement for an omino.

cellToPlacement
    For each coords on the grid, this is the list of placements that cover it.
    Effectively, a Map<Coords,Set<Placement>>, but API's extended to:
        add(placement) which puts the placement to every Coords in it.
        remove(placement,uncoverable) which removes the placement from every Coords in it,
        and adds any newly empty cell to uncoverable

The cellToPlacement is one data struct, but is effectively the many-to-many relationship from the algo.
We can go from cell to all its placements, and we can go from a placement to all its cells. We can also determine
which cells have the fewest placements available.

Move
    This is an actual move in the "game tree" of the algorithm. It specifies a particular placement and the
    needed information to undo that placement (and possibly any follow-on moves).
    placement - the actual placement
    blocked - the placements this move makes illegal, that were hence removed from the map by this move.
    examined - the placements from immediate child moves that have already been tried but failed
    uncoverable - any *coords* that no longer have placements in the map


move(placement)
    move.placement = placement
    map.remove(placement,mutableSet) // ignore newly empties
    for(cell in placement)
        for(remaining in cell)
            move.blocked += remaining
            map.remove(remaining,move.uncoverable)
    return move

map.add(placement)
    for(cell in placement)
        map[cell]+=placement

map.remove(placement,unreachables)
    // This placement is blocked by some other placement
    // We remove it as an option for every cell that has it
    // If that empties one of those cells, we may have actually bottomed out
    for cell in placement
        map[cell]-=placement
        if the cell has zero entries
            remove it from the map
            add it to unreachables

solve()
    find all placements and add them to the map
    while(there are cells in the map)
        pick a placement
        move = move(placement)
        if(move.unreachables) backtrack(move)
        else push(move)

backtrack(move)
    put move.placement in predecessor move.examined or solver's reset list
    for each placement in move.collisions + move.examined
        map.add(placement)

pick a placement
    sort the keys by number of placements in them.
    return the placement that has the fewest placements

Link
    List of coords.

Placement
    Conceptually, for a placement of order O there are O links. Each of these has the same constituents, but with
    a different zero'th member. ABC BAC CAB, for instance.

    links -- the O links for the placement
    collision links -- links that were removed because they conflict with links
    examined links -- links that following moves tried to use but failed

backtrack
    moves are kept in a stack that represent the part of the move tree we're exploring
    move = pop()
    previous = lastOrNull()
    put move's placement in previous's examined links list
        note: if you're popping the 0th move, its placements are truly dead. Put them on the solver's reset list.
    put move's collisions back in the map
    put move's examineds back in the map

reset
    backtrack until there are no placements
    restore the reset list

move
    pick a link
    links = link + its O-1 re-orderings
    remove links from table
    collisions = any table link that contains one of the placement's coordinates
    examined = []

backtrackIfNeeded
    Any time we don't have any links in the table, we've hit a dead end.
    We want to backtrack until the table has links again, which may be multiple times.
    If we still are out of links after we've emptied the stack, we have an unsolvable problem.

solve()
    generate all ominos
    generate all links
    while(placements<P)
        if backtrackIfNeeded still doesn't get links in the table
            exit with failure
        move


Given order O ominos in a W by H plane, the number of placements P = (W*H)/O, which must be an integer.
Example: pentominos in a 5x5 is P = 5. trominos in a 6x6 is P = 12.

While the solution doesn't have enough placements
    backtrackIfNeeded()
        while links is empty, and solution has placements backtrack
            pop the most recent placement
            put the collisions links back in the list
            put the dead links in the solution's reset list
        If there are no placements and no links we're dead!
    Pick a link

    Remove each link with the same constituents and put it in dead links.
        These are dead links, and will not come back. Either this tiling works, and doesn't come back,
        or we'll hit a dead end, and it means this placement isn't valid given the prior placements.

    Remove each link with *any* of the constituents and put it in backtrack links.
        There are backtrackable links, and may come back. If we backtrack, these are still valid links,
        because they're different from the one we chose.

If we exit the loop because we have enough placements, we have a solution.
If we run out of links, we have to backtrack.




